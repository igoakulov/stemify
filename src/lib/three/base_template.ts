import * as THREE from "three";
import { OrbitControls } from "three/examples/jsm/controls/OrbitControls.js";
import { CSS2DRenderer } from "three/examples/jsm/renderers/CSS2DRenderer.js";

import {
  STYLE_COLORS,
  create_style_materials,
  type StyleMaterials,
} from "@/lib/three/styleguide";

export type ThreeBaseTemplate = {
  renderer: THREE.WebGLRenderer;
  label_renderer: CSS2DRenderer;

  scene: THREE.Scene;
  root: THREE.Group;

  camera: THREE.PerspectiveCamera;
  controls: OrbitControls;
  materials: StyleMaterials;

  reset_camera: () => void;
  dispose: () => void;
};

export function create_three_base_template(
  canvas: HTMLCanvasElement,
  label_container: HTMLElement,
): ThreeBaseTemplate {
  const renderer = new THREE.WebGLRenderer({
    canvas,
    antialias: true,
    powerPreference: "high-performance",
  });

  renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
  renderer.outputColorSpace = THREE.SRGBColorSpace;

  const scene = new THREE.Scene();
  scene.background = new THREE.Color(STYLE_COLORS.background);

  const label_renderer = new CSS2DRenderer();
  label_renderer.domElement.style.position = "absolute";
  label_renderer.domElement.style.top = "0";
  label_renderer.domElement.style.left = "0";
  label_renderer.domElement.style.pointerEvents = "none";
  label_container.appendChild(label_renderer.domElement);

  // All scene content generated by sceneCode should be attached here.
  // This makes it easy to clear/reload scenes without recreating the renderer.
  const root = new THREE.Group();
  scene.add(root);

  const camera = new THREE.PerspectiveCamera(60, 1, 0.01, 500);
  const default_camera_position = new THREE.Vector3(6, 4, 8);
  const default_camera_target = new THREE.Vector3(0, 0, 0);

  camera.position.copy(default_camera_position);
  camera.lookAt(default_camera_target);

  const controls = new OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.dampingFactor = 0.08;
  controls.enablePan = false;
  controls.rotateSpeed = 0.65;
  controls.target.copy(default_camera_target);

  const materials = create_style_materials();

  // Deterministic light rig (base template owns lighting)
  const ambient = new THREE.AmbientLight(0xffffff, 0.55);
  scene.add(ambient);

  const key = new THREE.DirectionalLight(0xffffff, 0.85);
  key.position.set(6, 10, 8);
  scene.add(key);

  const fill = new THREE.DirectionalLight(0xffffff, 0.25);
  fill.position.set(-6, 4, -8);
  scene.add(fill);

  const reset_camera = () => {
    camera.position.copy(default_camera_position);
    controls.target.copy(default_camera_target);
    camera.lookAt(default_camera_target);
    controls.update();
  };

  const dispose = () => {
    controls.dispose();

    label_renderer.domElement.remove();

    renderer.dispose();

    materials.mesh_default.dispose();
    materials.mesh_accent.dispose();
    materials.grid_line.dispose();
  };

  return {
    renderer,
    label_renderer,
    scene,
    root,
    camera,
    controls,
    materials,
    reset_camera,
    dispose,
  };
}

export function resize_renderer_to_canvas(template: ThreeBaseTemplate): void {
  const canvas = template.renderer.domElement;
  const width = canvas.clientWidth;
  const height = canvas.clientHeight;

  if (width <= 0 || height <= 0) return;

  const needs_resize = canvas.width !== width || canvas.height !== height;

  if (needs_resize) {
    template.renderer.setSize(width, height, false);
    template.label_renderer.setSize(width, height);

    template.camera.aspect = width / height;
    template.camera.updateProjectionMatrix();
  }
}
